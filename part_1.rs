use rand::Rng;
use std::fs::File;
use std::io::BufRead;
use std::collections::VecDeque;
use std::vec;
use assert_approx_eq::assert_approx_eq;


// Final Project Part 1
// The goal is to calculate the "usual" or "average" distance between a pair of vertices in the graphs
// generated by the Amazon co-purchasing network for 3 different months. I want to investigate the idea of "6 degrees of separation" and see if
// various products can be connected to one another through no more than 6 other products.
// I will run a breadth-first-search from a random start node to a random end node. Since there are over 400,000 nodes in some of these txt files, I will
// randomly run the algorithm 1500 and take the average of those 1500 distances.


// creating a struct Graph
struct Graph {
    adj_list: Vec<Vec<usize>>,
}

// creating a struct Queue for my breadth-first-search algorithm
struct Queue<T> {
    items: VecDeque<T>,
}
impl<T> Queue<T> {
    // generating a new Queue
    fn generate_new() -> Queue<T> {
        Queue {
            items: VecDeque::new(),
        }
    }
    // insterting into back of the queue
    fn add_to_back_of_queue(&mut self, v: T) {
        self.items.push_back(v)
    }

    // returning and removing item from the front of the queue
    fn remove_from_front_queue(&mut self) -> T {
        self.items.pop_front().expect("Cannot dequeue from empty queue.")
    }

    // checking if the queue is empty
    fn is_queue_empty(&self) -> bool {
        self.items.len() == 0
    }
}

// creating an implementation on the struct Graph
impl Graph {
    fn new(file_path: &str) -> Self {
        let file = File::open(file_path).expect("Unable to open file");
        let buf_reader = std::io::BufReader::new(file).lines();
        let mut n: usize = 0;
        let mut adj_list: Vec<Vec<usize>> = vec![vec![]; n];
        for (_i, line) in buf_reader.enumerate() {
            let line_str = line.expect("Error reading");
            if _i == 0 {
                n = line_str.parse::<usize>().unwrap();
                adj_list = vec![vec![];n];
            } else {
                let v: Vec<&str> = line_str.trim().split_whitespace().collect();
                let x = v[0].parse::<usize>().unwrap();
                let y = v[1].parse::<usize>().unwrap();
                adj_list[x].push(y);
            }
        }
        return Graph {
            adj_list,
        };
    }

    // running a breadth first search algorithm where the function returns the path from the origin node to the final node
    fn bfs(&self) -> Option<Vec<Option<usize>>> {
        let mut rng = rand::thread_rng();
        let origin_node: usize = rng.gen_range(0..self.adj_list.len());
        let final_node: usize = rng.gen_range(0..self.adj_list.len());
        let mut queue = Queue::generate_new();
        queue.add_to_back_of_queue(origin_node);
        let mut visited_vertices = vec![false; self.adj_list.len()];
        visited_vertices[0] = true;

        //prev is used to record the order in which we visit the vertices
        let mut prev: Vec<Option<usize>> = vec![None; self.adj_list.len()];
        'outer: while !queue.is_queue_empty() {
            let current_node = queue.remove_from_front_queue();
            for v in self.adj_list[current_node as usize].iter() {
                if *v == final_node {
                    prev[*v as usize] = Some(current_node);
                    break 'outer;
                }
                if !visited_vertices[*v as usize] {
                    queue.add_to_back_of_queue(*v);
                    visited_vertices[*v as usize] = true;
                    prev[*v as usize] = Some(current_node);
                }
            }
        }
        let mut path = Vec::new();
        let mut at = Some(final_node);
        while at != None {
            path.push(at);
            at = prev[at.unwrap_or(0) as usize];
        }
        path.reverse();
        return match path[0] {
            Some(x) if x == origin_node => Some(path),
            _ => None,
        };
    }

    fn average_distance_between_vertices(&self) -> f32 {
        let data_file = Graph::new("facebook_combined.txt");
        let mut vec_of_distances: Vec<i32> = vec![];
        //in order to obtain 1500 paths from a random start-node to a random end-node, I will loop through the bfs algorithm 1500 bfs and collect
        // the resulting_vector_path which I will average out. 
        for _i in 1..=1500 {
            let resulting_vector_path = Graph::bfs(&data_file);
            //println!("the initial vector path is {:?}", resulting_vector_path);
            for _j in resulting_vector_path {
                //println!("the vector of the path is {:?}", _j);
                let mut distance: i32 = 0;
                for _i in _j {
                    // println!(" the value in the vector is {:?}", _i);
                    distance += 1;
                }
                //println!("the distance is {}", distance);
                vec_of_distances.push(distance);
            }
        }
        //println!("vector of the distances {:?}", vec_of_distances);
        let sum: i32 = vec_of_distances.iter().sum();
        let average_distance: f32 = (sum as f32) / (vec_of_distances.len() as f32);
        return average_distance;
        
    }
}

// use cargo run release for faster computation since there are over 260,000 nodes in these graphs.
pub fn main() {
    println!();
    println!(
        "The following computation is for the graph generated from the Amazon co-purchasing network dated March 2, 2003"
    );
    let data_file = Graph::new("amazon.txt");
    let the_distance = data_file.average_distance_between_vertices();
    println!("The average distance between a pair of vertices in this graph is {}.", the_distance);
    println!();
    println!(
        "The following computation is for the graph generated from the Amazon co-purchasing network dated June 1, 2003"
    );
    let data_file_2 = Graph::new("amazon_2.txt");
    let the_distance2 = data_file_2.average_distance_between_vertices();
    println!("The average distance between a pair of vertices in this graph is {}.", the_distance2);
    println!();
    println!(
        "The following computation is for the graph generated from the Amazon co-purchasing network dated May 5, 2003"
    );
    let data_file_3 = Graph::new("amazon_3.txt");
    let the_distance3 = data_file_3.average_distance_between_vertices();
    println!("The average distance between a pair of vertices in this graph is {}.", the_distance3);
    bfs_test()
  
    
}
// However many times I ran it, the average distance between a pair of vertices in all 3 Amazon co-purchasing networks was never above 6. It was most of the times in the
// range of 5 - 6, mainly around 5.5.


// The following below is a test case for my breadth-first search algorithm using the test_file.txt. The test case allows for some room in error (around 0.5) because
// the algorithm randomly picks out certain start and end nodes, so a certain range is expected.
fn bfs_test() {
    // the expected breadth first search distance between a pair of vertices calculated by using python
    let expected_bfs = 5.03;
    // calculated using my function
    let data_file_4 = Graph::new("test_file.txt");
    let calculated_bfs: f32 = data_file_4.average_distance_between_vertices();
    //assert_approx_eq!(expected_bfs,calculated_bfs);
    assert_approx_eq!(expected_bfs, calculated_bfs, 0.5f32);
}